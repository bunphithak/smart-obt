// Reports API - Connected to PostgreSQL Database
require('dotenv').config({ path: '.env.local' });
const { Pool } = require('pg');
const { formidable } = require('formidable');
const fs = require('fs').promises;
const path = require('path');
const { REPORT_STATUS, REPAIR_STATUS, PRIORITY } = require('../../lib/constants');
// const smsService = require('../../lib/smsService'); // à¸›à¸´à¸” SMS - à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸žà¸£à¹‰à¸­à¸¡à¹ƒà¸Šà¹‰à¸‡à¸²à¸™

const pool = new Pool({
  host: process.env.DB_HOST || 'localhost',
  port: parseInt(process.env.DB_PORT) || 5432,
  user: process.env.DB_USER || 'bunphithak',
  password: process.env.DB_PASSWORD || '',
  database: process.env.DB_NAME || 'smart_obt',
});

// Local storage is now used for file uploads

// Helper function to parse form data
const parseForm = async (req) => {
  return new Promise((resolve, reject) => {
    console.log('ðŸ” parseForm: Starting...');
    
    // Timeout after 10 seconds
    const timeout = setTimeout(() => {
      console.error('âŒ parseForm: TIMEOUT after 10 seconds!');
      reject(new Error('Form parsing timeout'));
    }, 10000);
    
    const uploadDir = path.join(process.cwd(), 'public', 'uploads');
    
    // Check if uploads directory exists, create if not
    const fs = require('fs');
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
      console.log('ðŸ“ Created uploads directory');
    }
    
    const form = formidable({
      uploadDir,
      keepExtensions: true,
      maxFileSize: 10 * 1024 * 1024, // 10MB
      multiples: true,
      allowEmptyFiles: true,
      minFileSize: 0,
    });

    console.log('ðŸ” parseForm: Calling form.parse()...');
    form.parse(req, (err, fields, files) => {
      clearTimeout(timeout); // Clear timeout if successful
      
      if (err) {
        console.error('âŒ Formidable parse error:', err);
        console.error('âŒ Error details:', {
          message: err.message,
          code: err.code,
          httpCode: err.httpCode
        });
        reject(err);
        return;
      }
      console.log('âœ… Form parsed successfully');
      console.log('ðŸ“Š Fields count:', Object.keys(fields).length);
      console.log('ðŸ“Š Files count:', Object.keys(files).length);
      resolve({ fields, files });
    });
  });
};

export default async function handler(req, res) {
  // Set CORS headers
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');

  // Handle preflight
  if (req.method === 'OPTIONS') {
    res.status(200).end();
    return;
  }

  const { method } = req;

  try {
    switch (method) {
      case 'POST':
        console.log('POST /api/reports - Processing form data...');
        console.log('ðŸ“‹ Request headers:', {
          'content-type': req.headers['content-type'],
          'content-length': req.headers['content-length']
        });
        
        // Parse multipart form data using formidable
        const { fields, files } = await parseForm(req);
        console.log('âœ… Form parsed successfully');
        
        // Extract fields (formidable wraps values in arrays)
        const assetCode = fields.assetCode?.[0];
        const problemType = fields.problemType?.[0];
        const reportTitle = fields.title?.[0];
        const description = fields.description?.[0];
        const location = fields.location?.[0];
        const reportedBy = fields.reporterName?.[0];
        const reporterPhone = fields.reporterPhone?.[0];
        const reportType = fields.reportType?.[0];
        const priority = fields.priority?.[0];
        const referrerUrl = fields.referrerUrl?.[0];
        
        // Continue with POST logic...
        console.log('ðŸ“¨ POST /api/reports - Starting...');
        console.log('ðŸ“¨ Content-Type:', req.headers['content-type']);
        
        try {
          console.log('ðŸ”„ Processing form data...');
          
          console.log('âœ… Form parsing complete');
          console.log('ðŸ“ Received fields:', Object.keys(fields));
          console.log('ðŸ“ Received files:', Object.keys(files));
          console.log('ðŸ“ Field details:', fields);
          
          // Extract fields (formidable wraps values in arrays)
          const reportAssetCode = (fields.assetCode?.[0] || fields.assetCode || '').toString().trim();
          const reportType = (fields.reportType?.[0] || fields.reportType || '').toString().trim();
          const categoryIdFromForm = (fields.categoryId?.[0] || fields.categoryId || "").toString().trim();
          const problemType = (fields.problemType?.[0] || fields.problemType || '').toString().trim();
          const title = (fields.title?.[0] || fields.title || '').toString().trim();
          const description = (fields.description?.[0] || fields.description || '').toString().trim();
          const priority = (fields.priority?.[0] || fields.priority || '').toString().trim();
          const reportedBy = (fields.reporterName?.[0] || fields.reporterName || '').toString().trim();
          const reporterPhone = (fields.reporterPhone?.[0] || fields.reporterPhone || '').toString().trim();
          const location = (fields.location?.[0] || fields.location || '').toString().trim();
          const gpsLocation = (fields.gpsLocation?.[0] || fields.gpsLocation || '').toString().trim();
          const coordinates = (fields.coordinates?.[0] || fields.coordinates || '').toString().trim();
          const referrerUrl = (fields.referrerUrl?.[0] || fields.referrerUrl || '').toString().trim();
          
          console.log('ðŸ“‹ Extracted data:', {
            reportType,
            problemType,
            reportedBy,
            reporterPhone,
            hasDescription: !!description
          });

          // Validate required fields based on report type
          if (reportType === 'repair') {
            // For repair reports, description is required
            if (!description) {
              return res.status(400).json({ 
                success: false, 
                error: 'à¸à¸£à¸¸à¸“à¸²à¸à¸£à¸­à¸à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸—à¸µà¹ˆà¸ˆà¸³à¹€à¸›à¹‡à¸™ (description)' 
              });
            }

            // Verify asset exists if assetCode is provided
            if (reportAssetCode) {
              const assetExists = await pool.query(
                'SELECT id, code FROM assets WHERE code = $1',
                [reportAssetCode]
              );

              if (assetExists.rows.length === 0) {
                return res.status(400).json({
                  success: false,
                  error: 'à¹„à¸¡à¹ˆà¸žà¸šà¸—à¸£à¸±à¸žà¸¢à¹Œà¸ªà¸´à¸™à¸—à¸µà¹ˆà¸£à¸°à¸šà¸¸'
                });
              }
            }
          } else if (reportType === 'request') {
            // For request, title and description are required
            if (!title || !description) {
              return res.status(400).json({ 
                success: false, 
                error: 'à¸à¸£à¸¸à¸“à¸²à¸à¸£à¸­à¸à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸—à¸µà¹ˆà¸ˆà¸³à¹€à¸›à¹‡à¸™ (title, description)' 
              });
            }
          } else {
            return res.status(400).json({ 
              success: false, 
              error: 'à¸›à¸£à¸°à¹€à¸ à¸—à¸£à¸²à¸¢à¸‡à¸²à¸™à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡' 
            });
          }

          // Process uploaded images to local storage
          console.log('ðŸ“¸ Processing images...');
          const imageUrls = [];
          if (files.images) {
            console.log('ðŸ“¸ Found images to upload to local storage');
            const imageFiles = Array.isArray(files.images) ? files.images : [files.images];
            
            try {
              const uploadsDir = path.join(process.cwd(), 'public', 'uploads');
              
              // Ensure uploads directory exists
              const fsSync = require('fs');
              if (!fsSync.existsSync(uploadsDir)) {
                fsSync.mkdirSync(uploadsDir, { recursive: true });
              }
              
              for (const file of imageFiles) {
                const originalName = file.originalFilename || 'image.jpg';
                const extension = path.extname(originalName);
                const timestamp = Date.now();
                const randomString = Math.random().toString(36).substring(2, 10);
                const filename = `report_${timestamp}_${randomString}${extension}`;
                const destinationPath = path.join(uploadsDir, filename);
                
                // Move file from temp location to permanent location
                await fs.rename(file.filepath, destinationPath);
                
                // Create public URL
                const publicUrl = `/uploads/${filename}`;
                imageUrls.push(publicUrl);
                
                console.log(`âœ… Uploaded image to local storage: ${filename}`);
              }
            } catch (uploadError) {
              console.error('âŒ Local upload error:', uploadError);
              console.error('âŒ Upload error stack:', uploadError.stack);
              // Continue without images if upload fails
            }
          } else {
            console.log('ðŸ“¸ No images to upload');
          }

          // Generate ticket ID with prefix based on type
          const prefix = reportType === 'repair' ? 'RP' : 'RQ';
          const timestamp = Date.now().toString();
          const newTicketId = `${prefix}${timestamp.slice(-8)}`;

          // Generate title for repair if not provided
          const reportTitle = title?.trim() || (reportType === 'repair' ? `à¹à¸ˆà¹‰à¸‡à¸‹à¹ˆà¸­à¸¡ ${reportAssetCode || 'à¸—à¸£à¸±à¸žà¸¢à¹Œà¸ªà¸´à¸™'}` : 'à¸„à¸³à¸£à¹‰à¸­à¸‡');

          // Parse coordinates if provided
          let coordinatesJson = null;
          if (coordinates && coordinates.trim() && coordinates !== 'undefined') {
            try {
              coordinatesJson = JSON.parse(coordinates);
              console.log('ðŸ“ Parsed coordinates:', coordinatesJson);
            } catch (e) {
              console.error('âš ï¸ Error parsing coordinates:', e);
              coordinatesJson = null;
            }
          } else {
            console.warn('âš ï¸ No coordinates to parse:', coordinates);
          }

          // Get category ID - prioritize from form, then from asset
          let categoryId = categoryIdFromForm || null;
          if (!categoryId && reportAssetCode) {
            try {
              const assetResult = await pool.query(
                'SELECT category_id FROM assets WHERE code = $1',
                [reportAssetCode]
              );
              if (assetResult.rows.length > 0) {
                categoryId = assetResult.rows[0].category_id;
              }
            } catch (e) {
              console.error('Error getting category from asset:', e);
            }
          }

          // Get problem_type UUID if problemType name is provided
          let problemTypeUuid = null;
          if (problemType && reportType === 'repair') {
            try {
              const ptQuery = categoryId 
                ? 'SELECT id, category_id FROM problem_types WHERE name = $1 AND category_id = $2 AND is_active = true'
                : 'SELECT id, category_id FROM problem_types WHERE name = $1 AND is_active = true';
              const ptParams = categoryId ? [problemType, categoryId] : [problemType];
              
              const ptResult = await pool.query(ptQuery, ptParams);
              if (ptResult.rows.length > 0) {
                problemTypeUuid = ptResult.rows[0].id;
                // If we don't have categoryId yet, get it from problem type
                if (!categoryId && ptResult.rows[0].category_id) {
                  categoryId = ptResult.rows[0].category_id;
                }
              }
            } catch (e) {
              console.error('Error fetching problem type UUID:', e);
            }
          }

          console.log('ðŸ’¾ Inserting to database...');
          console.log('ðŸ’¾ Values:', {
            ticketId: newTicketId,
            assetCode: reportAssetCode || null,
            reportType,
            problemType: problemTypeUuid,
            categoryId,
            title: reportTitle,
            hasDescription: !!description,
            hasImages: imageUrls.length > 0,
            hasCoordinates: !!coordinatesJson,
            coordinates: coordinatesJson,
            location: location?.trim() || ''
          });

          const result = await pool.query(`
            INSERT INTO reports (
              ticket_id, asset_code, report_type, problem_type, category_id, title, description,
              status, priority, reported_by, reporter_phone, images, location, coordinates, referrer_url
            )
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
            RETURNING *
          `, [
            newTicketId,
            reportAssetCode || null,
            reportType,
            problemTypeUuid,
            categoryId,
            reportTitle,
            description.trim(),
            ${REPORT_STATUS.PENDING},
            priority || PRIORITY.MEDIUM,
            reportedBy?.trim() || 'à¹„à¸¡à¹ˆà¸£à¸°à¸šà¸¸',
            reporterPhone?.trim() || '',
            JSON.stringify(imageUrls),
            location?.trim() || '',
            coordinatesJson ? JSON.stringify(coordinatesJson) : null,
            referrerUrl || null
          ]);

          const newReport = result.rows[0];
          
          console.log('âœ… Report created successfully:', {
            ticketId: newReport.ticket_id,
            reportType: newReport.report_type,
            reportedBy: newReport.reported_by
          });
          
          // Parse images safely
          let parsedImages = [];
          try {
            parsedImages = typeof newReport.images === 'string' 
              ? JSON.parse(newReport.images) 
              : (newReport.images || []);
          } catch (e) {
            console.error('âš ï¸ Error parsing images:', e);
            parsedImages = [];
          }
          
          // Parse coordinates safely
          let parsedCoordinates = null;
          try {
            parsedCoordinates = newReport.coordinates && typeof newReport.coordinates === 'string'
              ? JSON.parse(newReport.coordinates)
              : newReport.coordinates;
          } catch (e) {
            console.error('âš ï¸ Error parsing coordinates:', e);
            parsedCoordinates = null;
          }
          
          // à¸ªà¹ˆà¸‡ response à¸—à¸±à¸™à¸—à¸µà¸«à¸¥à¸±à¸‡à¸šà¸±à¸™à¸—à¸¶à¸à¹€à¸ªà¸£à¹‡à¸ˆ
          console.log('âœ… Sending response to client...');
          res.status(201).json({ 
            success: true, 
            ticketId: newReport.ticket_id,
            message: 'à¸šà¸±à¸™à¸—à¸¶à¸à¸£à¸²à¸¢à¸‡à¸²à¸™à¸ªà¸³à¹€à¸£à¹‡à¸ˆ',
            data: {
              id: newReport.id,
              ticketId: newReport.ticket_id,
              assetCode: newReport.asset_code,
              reportType: newReport.report_type,
              problemType: newReport.problem_type,
              title: newReport.title,
              description: newReport.description,
              status: newReport.status,
              priority: newReport.priority,
              reportedBy: newReport.reported_by,
              reporterPhone: newReport.reporter_phone,
              reportedAt: newReport.reported_at,
              images: parsedImages,
              location: newReport.location,
              coordinates: parsedCoordinates,
              createdAt: newReport.created_at
            }
          });
        } catch (parseError) {
          console.error('âŒ POST /api/reports Error:', parseError);
          console.error('âŒ Error stack:', parseError.stack);
          return res.status(400).json({
            success: false,
            error: 'à¹€à¸à¸´à¸”à¸‚à¹‰à¸­à¸œà¸´à¸”à¸žà¸¥à¸²à¸”à¹ƒà¸™à¸à¸²à¸£à¸­à¹ˆà¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥',
            details: parseError.message,
            stack: process.env.NODE_ENV === 'development' ? parseError.stack : undefined
          });
        }
        break;

      case 'GET':
        console.log('GET /api/reports - Query:', req.query);
        const { id, assetCode: queryAssetCode, status, ticketId, public: isPublic } = req.query;
        
        if (id) {
          // Get single report with asset and village info
          // Public access for print functionality (no authentication required)
          const result = await pool.query(`
            SELECT 
              r.*,
              a.name as asset_name,
              a.code as asset_code,
              v.name as village_name
            FROM reports r
            LEFT JOIN assets a ON r.asset_code = a.code
            LEFT JOIN villages v ON a.village_id = v.id
            WHERE r.id = $1
          `, [id]);

          if (result.rows.length === 0) {
            return res.status(404).json({ 
              success: false, 
              error: 'à¹„à¸¡à¹ˆà¸žà¸šà¸£à¸²à¸¢à¸‡à¸²à¸™à¸—à¸µà¹ˆà¸£à¸°à¸šà¸¸' 
            });
          }

          const report = result.rows[0];
          res.status(200).json({ 
            success: true, 
            data: {
              id: report.id,
              ticketId: report.ticket_id,
              assetCode: report.asset_code,
              assetName: report.asset_name,
              villageName: report.village_name,
              reportType: report.report_type,
              problemType: report.problem_type,
              title: report.title,
              description: report.description,
              status: report.status,
              priority: report.priority,
              reportedBy: report.reported_by,
              reporterPhone: report.reporter_phone,
              reportedAt: report.reported_at,
              images: report.images || [],
              location: report.location,
              coordinates: report.coordinates, // âœ… à¹€à¸žà¸´à¹ˆà¸¡ coordinates
              createdAt: report.created_at,
              updatedAt: report.updated_at
            }
          });
        } else {
          // Build query with filters
          let query = `
            SELECT 
              r.*,
              a.name as asset_name,
              a.code as asset_code,
              v.name as village_name
            FROM reports r
            LEFT JOIN assets a ON r.asset_code = a.code
            LEFT JOIN villages v ON a.village_id = v.id
            WHERE 1=1
          `;
          const queryParams = [];
          let paramIndex = 1;

          if (queryAssetCode) {
            query += ` AND r.asset_code = $${paramIndex}`;
            queryParams.push(queryAssetCode);
            paramIndex++;
          }

          if (status) {
            query += ` AND r.status = $${paramIndex}`;
            queryParams.push(status);
            paramIndex++;
          }

          if (ticketId) {
            query += ` AND r.ticket_id = $${paramIndex}`;
            queryParams.push(ticketId);
            paramIndex++;
          }

          query += ` ORDER BY r.reported_at DESC`;

          const result = await pool.query(query, queryParams);
          
          const reports = result.rows.map(row => ({
            id: row.id,
            ticketId: row.ticket_id,
            assetCode: row.asset_code,
            assetName: row.asset_name,
            villageName: row.village_name,
            reportType: row.report_type,
            problemType: row.problem_type,
            title: row.title,
            description: row.description,
            status: row.status,
            priority: row.priority,
            reportedBy: row.reported_by,
            reporterPhone: row.reporter_phone,
            reportedAt: row.reported_at,
            images: row.images || [],
            location: row.location,
            createdAt: row.created_at,
            updatedAt: row.updated_at
          }));

          res.status(200).json({ 
            success: true, 
            data: reports,
            total: reports.length
          });
        }
        break;

      case 'POST':
        console.log('ðŸ“¨ POST /api/reports - Starting...');
        console.log('ðŸ“¨ Content-Type:', req.headers['content-type']);
        
        try {
          console.log('ðŸ”„ Parsing form data...');
          // Parse multipart form data
          const { fields, files } = await parseForm(req);
          
          console.log('âœ… Form parsing complete');
          console.log('ðŸ“ Received fields:', Object.keys(fields));
          console.log('ðŸ“ Received files:', Object.keys(files));
          console.log('ðŸ“ Field details:', fields);
          
          // Extract fields (formidable wraps values in arrays)
          const reportAssetCode = (fields.assetCode?.[0] || fields.assetCode || '').toString().trim();
          const reportType = (fields.reportType?.[0] || fields.reportType || '').toString().trim();
          const problemType = (fields.problemType?.[0] || fields.problemType || '').toString().trim();
          const title = (fields.title?.[0] || fields.title || '').toString().trim();
          const description = (fields.description?.[0] || fields.description || '').toString().trim();
          const priority = (fields.priority?.[0] || fields.priority || '').toString().trim();
          const reportedBy = (fields.reporterName?.[0] || fields.reporterName || '').toString().trim();
          const reporterPhone = (fields.reporterPhone?.[0] || fields.reporterPhone || '').toString().trim();
          const location = (fields.location?.[0] || fields.location || '').toString().trim();
          const gpsLocation = (fields.gpsLocation?.[0] || fields.gpsLocation || '').toString().trim();
          const coordinates = (fields.coordinates?.[0] || fields.coordinates || '').toString().trim();
          const referrerUrl = (fields.referrerUrl?.[0] || fields.referrerUrl || '').toString().trim();
          
          console.log('ðŸ“‹ Extracted data:', {
            reportType,
            problemType,
            reportedBy,
            reporterPhone,
            hasDescription: !!description
          });

          // Validate required fields based on report type
          if (reportType === 'repair') {
            // For repair reports, description is required
            if (!description) {
              return res.status(400).json({ 
                success: false, 
                error: 'à¸à¸£à¸¸à¸“à¸²à¸à¸£à¸­à¸à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸—à¸µà¹ˆà¸ˆà¸³à¹€à¸›à¹‡à¸™ (description)' 
              });
            }

            // Verify asset exists if assetCode is provided
            if (reportAssetCode) {
              const assetExists = await pool.query(
                'SELECT id, code FROM assets WHERE code = $1',
                [reportAssetCode]
              );

              if (assetExists.rows.length === 0) {
                return res.status(400).json({
                  success: false,
                  error: 'à¹„à¸¡à¹ˆà¸žà¸šà¸—à¸£à¸±à¸žà¸¢à¹Œà¸ªà¸´à¸™à¸—à¸µà¹ˆà¸£à¸°à¸šà¸¸'
                });
              }
            }
          } else if (reportType === 'request') {
            // For request, title and description are required
            if (!title || !description) {
              return res.status(400).json({ 
                success: false, 
                error: 'à¸à¸£à¸¸à¸“à¸²à¸à¸£à¸­à¸à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸—à¸µà¹ˆà¸ˆà¸³à¹€à¸›à¹‡à¸™ (title, description)' 
              });
            }
          } else {
            return res.status(400).json({ 
              success: false, 
              error: 'à¸›à¸£à¸°à¹€à¸ à¸—à¸£à¸²à¸¢à¸‡à¸²à¸™à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡' 
            });
          }

          // Process uploaded images to local storage
          console.log('ðŸ“¸ Processing images...');
          const imageUrls = [];
          if (files.images) {
            console.log('ðŸ“¸ Found images to upload to local storage');
            const imageFiles = Array.isArray(files.images) ? files.images : [files.images];
            
            try {
              const uploadsDir = path.join(process.cwd(), 'public', 'uploads');
              
              // Ensure uploads directory exists
              const fsSync = require('fs');
              if (!fsSync.existsSync(uploadsDir)) {
                fsSync.mkdirSync(uploadsDir, { recursive: true });
              }
              
              for (const file of imageFiles) {
                const originalName = file.originalFilename || 'image.jpg';
                const extension = path.extname(originalName);
                const timestamp = Date.now();
                const randomString = Math.random().toString(36).substring(2, 10);
                const filename = `report_${timestamp}_${randomString}${extension}`;
                const destinationPath = path.join(uploadsDir, filename);
                
                // Move file from temp location to permanent location
                await fs.rename(file.filepath, destinationPath);
                
                // Create public URL
                const publicUrl = `/uploads/${filename}`;
                imageUrls.push(publicUrl);
                
                console.log(`âœ… Uploaded image to local storage: ${filename}`);
              }
            } catch (uploadError) {
              console.error('âŒ Local upload error:', uploadError);
              console.error('âŒ Upload error stack:', uploadError.stack);
              // Continue without images if upload fails
            }
          } else {
            console.log('ðŸ“¸ No images to upload');
          }

          // Generate ticket ID with prefix based on type
          const prefix = reportType === 'repair' ? 'RP' : 'RQ';
          const timestamp = Date.now().toString();
          const newTicketId = `${prefix}${timestamp.slice(-8)}`;

          // Generate title for repair if not provided
          const reportTitle = title?.trim() || (reportType === 'repair' ? `à¹à¸ˆà¹‰à¸‡à¸‹à¹ˆà¸­à¸¡ ${reportAssetCode || 'à¸—à¸£à¸±à¸žà¸¢à¹Œà¸ªà¸´à¸™'}` : 'à¸„à¸³à¸£à¹‰à¸­à¸‡');

          // Parse coordinates if provided
          let coordinatesJson = null;
          if (coordinates && coordinates.trim() && coordinates !== 'undefined') {
            try {
              coordinatesJson = JSON.parse(coordinates);
              console.log('ðŸ“ Parsed coordinates:', coordinatesJson);
            } catch (e) {
              console.error('âš ï¸ Error parsing coordinates:', e);
              coordinatesJson = null;
            }
          } else {
            console.warn('âš ï¸ No coordinates to parse:', coordinates);
          }

          // Get category ID - prioritize from form, then from asset
          let categoryId = categoryIdFromForm || null;
          if (!categoryId && reportAssetCode) {
            try {
              const assetResult = await pool.query(
                'SELECT category_id FROM assets WHERE code = $1',
                [reportAssetCode]
              );
              if (assetResult.rows.length > 0) {
                categoryId = assetResult.rows[0].category_id;
              }
            } catch (e) {
              console.error('Error getting category from asset:', e);
            }
          }

          // Get problem_type UUID if problemType name is provided
          let problemTypeUuid = null;
          if (problemType && reportType === 'repair') {
            try {
              const ptQuery = categoryId 
                ? 'SELECT id, category_id FROM problem_types WHERE name = $1 AND category_id = $2 AND is_active = true'
                : 'SELECT id, category_id FROM problem_types WHERE name = $1 AND is_active = true';
              const ptParams = categoryId ? [problemType, categoryId] : [problemType];
              
              const ptResult = await pool.query(ptQuery, ptParams);
              if (ptResult.rows.length > 0) {
                problemTypeUuid = ptResult.rows[0].id;
                // If we don't have categoryId yet, get it from problem type
                if (!categoryId && ptResult.rows[0].category_id) {
                  categoryId = ptResult.rows[0].category_id;
                }
              }
            } catch (e) {
              console.error('Error fetching problem type UUID:', e);
            }
          }

          console.log('ðŸ’¾ Inserting to database...');
          console.log('ðŸ’¾ Values:', {
            ticketId: newTicketId,
            assetCode: reportAssetCode || null,
            reportType,
            problemType: problemTypeUuid,
            categoryId,
            title: reportTitle,
            hasDescription: !!description,
            hasImages: imageUrls.length > 0,
            hasCoordinates: !!coordinatesJson,
            coordinates: coordinatesJson,
            location: location?.trim() || ''
          });

          const result = await pool.query(`
            INSERT INTO reports (
              ticket_id, asset_code, report_type, problem_type, category_id, title, description,
              status, priority, reported_by, reporter_phone, images, location, coordinates, referrer_url
            )
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
            RETURNING *
          `, [
            newTicketId,
            reportAssetCode || null,
            reportType,
            problemTypeUuid,
            categoryId,
            reportTitle,
            description.trim(),
            ${REPORT_STATUS.PENDING},
            priority || PRIORITY.MEDIUM,
            reportedBy?.trim() || 'à¹„à¸¡à¹ˆà¸£à¸°à¸šà¸¸',
            reporterPhone?.trim() || '',
            JSON.stringify(imageUrls),
            location?.trim() || '',
            coordinatesJson ? JSON.stringify(coordinatesJson) : null,
            referrerUrl || null
          ]);

          const newReport = result.rows[0];
          
          console.log('âœ… Report created successfully:', {
            ticketId: newReport.ticket_id,
            reportType: newReport.report_type,
            reportedBy: newReport.reported_by
          });
          
          // Parse images safely
          let parsedImages = [];
          try {
            parsedImages = typeof newReport.images === 'string' 
              ? JSON.parse(newReport.images) 
              : (newReport.images || []);
          } catch (e) {
            console.error('âš ï¸ Error parsing images:', e);
            parsedImages = [];
          }
          
          // Parse coordinates safely
          let parsedCoordinates = null;
          try {
            parsedCoordinates = newReport.coordinates && typeof newReport.coordinates === 'string'
              ? JSON.parse(newReport.coordinates)
              : newReport.coordinates;
          } catch (e) {
            console.error('âš ï¸ Error parsing coordinates:', e);
            parsedCoordinates = null;
          }
          
          // à¸ªà¹ˆà¸‡ response à¸—à¸±à¸™à¸—à¸µà¸«à¸¥à¸±à¸‡à¸šà¸±à¸™à¸—à¸¶à¸à¹€à¸ªà¸£à¹‡à¸ˆ
          console.log('âœ… Sending response to client...');
          res.status(201).json({ 
            success: true, 
            ticketId: newReport.ticket_id,
            message: 'à¸šà¸±à¸™à¸—à¸¶à¸à¸£à¸²à¸¢à¸‡à¸²à¸™à¸ªà¸³à¹€à¸£à¹‡à¸ˆ',
            data: {
              id: newReport.id,
              ticketId: newReport.ticket_id,
              assetCode: newReport.asset_code,
              reportType: newReport.report_type,
              problemType: newReport.problem_type,
              title: newReport.title,
              description: newReport.description,
              status: newReport.status,
              priority: newReport.priority,
              reportedBy: newReport.reported_by,
              reporterPhone: newReport.reporter_phone,
              reportedAt: newReport.reported_at,
              images: parsedImages,
              location: newReport.location,
              coordinates: parsedCoordinates,
              createdAt: newReport.created_at
            }
          });
        } catch (parseError) {
          console.error('âŒ POST /api/reports Error:', parseError);
          console.error('âŒ Error stack:', parseError.stack);
          return res.status(400).json({
            success: false,
            error: 'à¹€à¸à¸´à¸”à¸‚à¹‰à¸­à¸œà¸´à¸”à¸žà¸¥à¸²à¸”à¹ƒà¸™à¸à¸²à¸£à¸­à¹ˆà¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥',
            details: parseError.message,
            stack: process.env.NODE_ENV === 'development' ? parseError.stack : undefined
          });
        }
        break;

      case 'PUT':
        const { 
          id: updateId, 
          status: updateStatus, 
          priority: updatePriority, 
          description: updateDescription,
          images: updateImages,
          note: updateNote,
          rejectionReason: updateRejectionReason
        } = req.body;

        if (!updateId) {
          return res.status(400).json({ 
            success: false, 
            error: 'à¸à¸£à¸¸à¸“à¸²à¸£à¸°à¸šà¸¸ ID à¸‚à¸­à¸‡à¸£à¸²à¸¢à¸‡à¸²à¸™' 
          });
        }

        // Check if report exists
        const reportExists = await pool.query(
          'SELECT id FROM reports WHERE id = $1',
          [updateId]
        );

        if (reportExists.rows.length === 0) {
          return res.status(404).json({
            success: false,
            error: 'à¹„à¸¡à¹ˆà¸žà¸šà¸£à¸²à¸¢à¸‡à¸²à¸™à¸—à¸µà¹ˆà¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¸­à¸±à¸›à¹€à¸”à¸•'
          });
        }

        // Get the current status before update
        const currentReport = await pool.query(
          'SELECT status, report_type FROM reports WHERE id = $1',
          [updateId]
        );
        const oldStatus = currentReport.rows[0]?.status;

        const updateResult = await pool.query(`
          UPDATE reports 
          SET status = COALESCE($2, status),
              priority = COALESCE($3, priority),
              description = COALESCE($4, description),
              images = COALESCE($5, images),
              rejection_reason = COALESCE($6, rejection_reason),
              updated_at = NOW()
          WHERE id = $1
          RETURNING *
        `, [
          updateId,
          updateStatus,
          updatePriority,
          updateDescription?.trim(),
          updateImages ? JSON.stringify(updateImages) : null,
          updateRejectionReason?.trim()
        ]);

        const updatedReport = updateResult.rows[0];

        // à¸–à¹‰à¸²à¸ªà¸–à¸²à¸™à¸°à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¸ˆà¸²à¸ "à¸£à¸­à¸”à¸³à¹€à¸™à¸´à¸™à¸à¸²à¸£" à¹€à¸›à¹‡à¸™ "à¸­à¸™à¸¸à¸¡à¸±à¸•à¸´" à¹ƒà¸«à¹‰à¸ªà¸£à¹‰à¸²à¸‡à¸‡à¸²à¸™à¸‹à¹ˆà¸­à¸¡à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´
        if (oldStatus === ${REPORT_STATUS.PENDING} && updateStatus === 'à¸­à¸™à¸¸à¸¡à¸±à¸•à¸´') {
          try {
            console.log('ðŸ”§ Creating repair job automatically for approved report:', updateId);
            console.log('ðŸ“‹ Report data:', updatedReport);
            
            // Parse coordinates safely
            let lat = null;
            let lng = null;
            if (updatedReport.coordinates) {
              try {
                const coords = typeof updatedReport.coordinates === 'string' 
                  ? JSON.parse(updatedReport.coordinates) 
                  : updatedReport.coordinates;
                lat = coords?.lat || null;
                lng = coords?.lng || null;
                console.log('ðŸ“ Coordinates:', { lat, lng });
              } catch (coordError) {
                console.warn('âš ï¸ Could not parse coordinates:', coordError);
              }
            }
            
            // à¸ªà¸£à¹‰à¸²à¸‡à¸‡à¸²à¸™à¸‹à¹ˆà¸­à¸¡à¹ƒà¸«à¸¡à¹ˆ
            const repairResult = await pool.query(`
              INSERT INTO repairs (
                report_id,
                asset_code,
                title,
                description,
                status,
                priority,
                location,
                latitude,
                longitude,
                images,
                created_at,
                updated_at
              ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW(), NOW())
              RETURNING *
            `, [
              updatedReport.id,
              updatedReport.asset_code,
              updatedReport.title,
              updatedReport.description,
              ${REPORT_STATUS.PENDING}, // à¸ªà¸–à¸²à¸™à¸°à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸‚à¸­à¸‡à¸‡à¸²à¸™à¸‹à¹ˆà¸­à¸¡
              updatedReport.priority || PRIORITY.MEDIUM,
              updatedReport.location,
              lat,
              lng,
              updatedReport.images
            ]);

            console.log('âœ… Repair job created:', repairResult.rows[0].id);

            return res.status(200).json({ 
              success: true, 
              message: 'à¸­à¸±à¸›à¹€à¸”à¸•à¸£à¸²à¸¢à¸‡à¸²à¸™à¸ªà¸³à¹€à¸£à¹‡à¸ˆà¹à¸¥à¸°à¸ªà¸£à¹‰à¸²à¸‡à¸‡à¸²à¸™à¸‹à¹ˆà¸­à¸¡à¹à¸¥à¹‰à¸§',
              data: updatedReport,
              repairId: repairResult.rows[0].id
            });
          } catch (repairError) {
            console.error('âŒ Error creating repair job:', repairError);
            console.error('âŒ Error stack:', repairError.stack);
            // à¸–à¸¶à¸‡à¹à¸¡à¹‰à¸ªà¸£à¹‰à¸²à¸‡à¸‡à¸²à¸™à¸‹à¹ˆà¸­à¸¡à¹„à¸¡à¹ˆà¸ªà¸³à¹€à¸£à¹‡à¸ˆ à¹à¸•à¹ˆà¸à¸²à¸£à¸­à¸±à¸›à¹€à¸”à¸•à¸£à¸²à¸¢à¸‡à¸²à¸™à¸¢à¸±à¸‡à¸ªà¸³à¹€à¸£à¹‡à¸ˆà¸­à¸¢à¸¹à¹ˆ
            return res.status(200).json({ 
              success: true, 
              message: 'à¸­à¸±à¸›à¹€à¸”à¸•à¸£à¸²à¸¢à¸‡à¸²à¸™à¸ªà¸³à¹€à¸£à¹‡à¸ˆ (à¹à¸•à¹ˆà¸ªà¸£à¹‰à¸²à¸‡à¸‡à¸²à¸™à¸‹à¹ˆà¸­à¸¡à¹„à¸¡à¹ˆà¸ªà¸³à¹€à¸£à¹‡à¸ˆ)',
              data: updatedReport,
              error: repairError.message
            });
          }
        }

        res.status(200).json({ 
          success: true, 
          message: 'à¸­à¸±à¸›à¹€à¸”à¸•à¸£à¸²à¸¢à¸‡à¸²à¸™à¸ªà¸³à¹€à¸£à¹‡à¸ˆ',
          data: updatedReport
        });
        break;

      case 'DELETE':
        const { id: deleteId } = req.query;
        
        if (!deleteId) {
          return res.status(400).json({ 
            success: false, 
            error: 'à¸à¸£à¸¸à¸“à¸²à¸£à¸°à¸šà¸¸ ID à¸‚à¸­à¸‡à¸£à¸²à¸¢à¸‡à¸²à¸™à¸—à¸µà¹ˆà¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¸¥à¸š' 
          });
        }

        // Check if report exists
        const reportToDelete = await pool.query(
          'SELECT id FROM reports WHERE id = $1',
          [deleteId]
        );

        if (reportToDelete.rows.length === 0) {
          return res.status(404).json({
            success: false,
            error: 'à¹„à¸¡à¹ˆà¸žà¸šà¸£à¸²à¸¢à¸‡à¸²à¸™à¸—à¸µà¹ˆà¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¸¥à¸š'
          });
        }

        // Check if report has repairs
        const repairsCheck = await pool.query(
          'SELECT COUNT(*) as count FROM repairs WHERE report_id = $1',
          [deleteId]
        );

        if (parseInt(repairsCheck.rows[0].count) > 0) {
          return res.status(400).json({
            success: false,
            error: 'à¹„à¸¡à¹ˆà¸ªà¸²à¸¡à¸²à¸£à¸–à¸¥à¸šà¸£à¸²à¸¢à¸‡à¸²à¸™à¸—à¸µà¹ˆà¸¡à¸µà¸‡à¸²à¸™à¸‹à¹ˆà¸­à¸¡à¹„à¸”à¹‰'
          });
        }

        await pool.query('DELETE FROM reports WHERE id = $1', [deleteId]);
        
        res.status(200).json({ 
          success: true, 
          message: 'à¸¥à¸šà¸£à¸²à¸¢à¸‡à¸²à¸™à¸ªà¸³à¹€à¸£à¹‡à¸ˆ' 
        });
        break;

      default:
        res.setHeader('Allow', ['GET', 'POST', 'PUT', 'DELETE']);
        res.status(405).json({ success: false, error: `Method ${method} Not Allowed` });
    }

  } catch (error) {
    console.error('Reports API Error:', error);
    res.status(500).json({
      success: false,
      message: 'Internal server error',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
}

// Configure API route - DISABLE body parser for formidable to work
export const config = {
  api: {
    bodyParser: false, // âœ… à¸›à¸´à¸” Next.js body parser à¹€à¸žà¸·à¹ˆà¸­à¹ƒà¸«à¹‰ formidable à¸—à¸³à¸‡à¸²à¸™à¹„à¸”à¹‰
  },
};